#include <string.h>
#include <ctype.h>

#include "phase.h"

// The table below contains information about the available tokens. The
// order of the table corresponds to the order of the token enumeration.
#define ENTRY( text, flags ) \
   { text, ARRAY_SIZE( text ) - 1, flags }
#define BLANK ""
static struct token_info g_table[] = {
   // 0
   ENTRY( BLANK, TKF_NONE ),
   ENTRY( BLANK, TKF_NONE ),
   ENTRY( "[", TKF_NONE ),
   ENTRY( "]", TKF_NONE ),
   ENTRY( "(", TKF_NONE ),
   ENTRY( ")", TKF_NONE ),
   ENTRY( "{", TKF_NONE ),
   ENTRY( "}", TKF_NONE ),
   ENTRY( ".", TKF_NONE ),
   ENTRY( "++", TKF_NONE ),
   // 10
   ENTRY( "--", TKF_NONE ),
   ENTRY( BLANK, TKF_NONE ),
   ENTRY( ",", TKF_NONE ),
   ENTRY( ":", TKF_NONE ),
   ENTRY( "strcpy", TKF_KEYWORD ),
   ENTRY( ";", TKF_NONE ),
   ENTRY( "=", TKF_NONE ),
   ENTRY( "+=", TKF_NONE ),
   ENTRY( "-=", TKF_NONE ),
   ENTRY( "*=", TKF_NONE ),
   // 20
   ENTRY( "/=", TKF_NONE ),
   ENTRY( "%=", TKF_NONE ),
   ENTRY( "<<=", TKF_NONE ),
   ENTRY( ">>=", TKF_NONE ),
   ENTRY( "&=", TKF_NONE ),
   ENTRY( "^=", TKF_NONE ),
   ENTRY( "|=", TKF_NONE ),
   ENTRY( "==", TKF_NONE ),
   ENTRY( "!=", TKF_NONE ),
   ENTRY( "!", TKF_NONE ),
   // 30
   ENTRY( "&&", TKF_NONE ),
   ENTRY( "||", TKF_NONE ),
   ENTRY( "&", TKF_NONE ),
   ENTRY( "|", TKF_NONE ),
   ENTRY( "^", TKF_NONE ),
   ENTRY( "~", TKF_NONE ),
   ENTRY( "<", TKF_NONE ),
   ENTRY( "<=", TKF_NONE ),
   ENTRY( ">", TKF_NONE ),
   ENTRY( ">=", TKF_NONE ),
   // 40
   ENTRY( "+", TKF_NONE ),
   ENTRY( "-", TKF_NONE ),
   ENTRY( "/", TKF_NONE ),
   ENTRY( "*", TKF_NONE ),
   ENTRY( "%", TKF_NONE ),
   ENTRY( "<<", TKF_NONE ),
   ENTRY( ">>", TKF_NONE ),
   ENTRY( "break", TKF_KEYWORD ),
   ENTRY( "case", TKF_KEYWORD ),
   ENTRY( "const", TKF_KEYWORD ),
   // 50
   ENTRY( "continue", TKF_KEYWORD ),
   ENTRY( "default", TKF_KEYWORD ),
   ENTRY( "do", TKF_KEYWORD ),
   ENTRY( "else", TKF_KEYWORD ),
   ENTRY( "enum", TKF_KEYWORD ),
   ENTRY( "for", TKF_KEYWORD ),
   ENTRY( "if", TKF_KEYWORD ),
   ENTRY( "int", TKF_KEYWORD ),
   ENTRY( "return", TKF_KEYWORD ),
   ENTRY( "static", TKF_KEYWORD ),
   // 60
   ENTRY( "str", TKF_KEYWORD ),
   ENTRY( "struct", TKF_KEYWORD ),
   ENTRY( "switch", TKF_KEYWORD ),
   ENTRY( "void", TKF_KEYWORD ),
   ENTRY( "while", TKF_KEYWORD ),
   ENTRY( "bool", TKF_KEYWORD ),
   ENTRY( BLANK, TKF_NONE ),
   ENTRY( BLANK, TKF_NONE ),
   ENTRY( BLANK, TKF_NONE ),
   ENTRY( BLANK, TKF_NONE ),
   // 70
   ENTRY( BLANK, TKF_NONE ),
   ENTRY( BLANK, TKF_NONE ),
   ENTRY( "#", TKF_NONE ),
   ENTRY( "createtranslation", TKF_KEYWORD ),
   ENTRY( "global", TKF_KEYWORD ),
   ENTRY( "script", TKF_KEYWORD ),
   ENTRY( "until", TKF_KEYWORD ),
   ENTRY( "world", TKF_KEYWORD ),
   ENTRY( "open", TKF_KEYWORD ),
   ENTRY( "respawn", TKF_KEYWORD ),
   // 80
   ENTRY( "death", TKF_KEYWORD ),
   ENTRY( "enter", TKF_KEYWORD ),
   ENTRY( "pickup", TKF_KEYWORD ),
   ENTRY( "bluereturn", TKF_KEYWORD ),
   ENTRY( "redreturn", TKF_KEYWORD ),
   ENTRY( "whitereturn", TKF_KEYWORD ),
   ENTRY( "lightning", TKF_KEYWORD ),
   ENTRY( "disconnect", TKF_KEYWORD ),
   ENTRY( "unloading", TKF_KEYWORD ),
   ENTRY( "clientside", TKF_KEYWORD ),
   // 90
   ENTRY( "net", TKF_KEYWORD ),
   ENTRY( "restart", TKF_KEYWORD ),
   ENTRY( "suspend", TKF_KEYWORD ),
   ENTRY( "terminate", TKF_KEYWORD ),
   ENTRY( "function", TKF_KEYWORD ),
   ENTRY( "import", TKF_KEYWORD ),
   ENTRY( "goto", TKF_KEYWORD ),
   ENTRY( "true", TKF_KEYWORD ),
   ENTRY( "false", TKF_KEYWORD ),
   ENTRY( "event", TKF_KEYWORD ),
   // 100
   ENTRY( BLANK, TKF_NONE ),
   ENTRY( BLANK, TKF_NONE ),
   ENTRY( BLANK, TKF_NONE ),
   ENTRY( BLANK, TKF_NONE ),
   ENTRY( "?", TKF_KEYWORD ),
   ENTRY( " ", TKF_KEYWORD ),
   ENTRY( "\t", TKF_KEYWORD ),
   ENTRY( "...", TKF_KEYWORD ),
   ENTRY( " ", TKF_NONE ),
   ENTRY( "##", TKF_NONE ),
   // 110
   ENTRY( "raw", TKF_KEYWORD ),
   ENTRY( "fixed", TKF_KEYWORD ),
   ENTRY( "assert", TKF_KEYWORD ),
   ENTRY( "auto", TKF_KEYWORD ),
   ENTRY( "typedef", TKF_KEYWORD ),
   ENTRY( "foreach", TKF_KEYWORD ),
   ENTRY( "private", TKF_KEYWORD ),
   ENTRY( "memcpy", TKF_KEYWORD ),
   ENTRY( "msgbuild", TKF_KEYWORD ),
   ENTRY( "null", TKF_KEYWORD ),
   // 120
   ENTRY( "special", TKF_KEYWORD ),
   ENTRY( "namespace", TKF_KEYWORD ),
   ENTRY( "upmost", TKF_KEYWORD ),
   ENTRY( "using", TKF_KEYWORD ),
   ENTRY( "include", TKF_KEYWORD ),
   ENTRY( "define", TKF_KEYWORD ),
   ENTRY( "libdefine", TKF_KEYWORD ),
   ENTRY( "print", TKF_KEYWORD ),
   ENTRY( "printbold", TKF_KEYWORD ),
   ENTRY( "wadauthor", TKF_KEYWORD ),
   // 130
   ENTRY( "nowadauthor", TKF_KEYWORD ),
   ENTRY( "nocompact", TKF_KEYWORD ),
   ENTRY( "library", TKF_KEYWORD ),
   ENTRY( "encryptstrings", TKF_KEYWORD ),
   ENTRY( "region", TKF_KEYWORD ),
   ENTRY( "endregion", TKF_KEYWORD ),
   ENTRY( "log", TKF_KEYWORD ),
   ENTRY( "hudmessage", TKF_KEYWORD ),
   ENTRY( "hudmessagebold", TKF_KEYWORD ),
   ENTRY( "strparam", TKF_KEYWORD ),
   // 140
   ENTRY( "extern", TKF_KEYWORD ),
   ENTRY( "acs_executewait", TKF_KEYWORD ),
   ENTRY( "acs_namedexecutewait", TKF_KEYWORD ),
   ENTRY( BLANK, TKF_NONE ),
   ENTRY( BLANK, TKF_NONE ),
   ENTRY( "kill", TKF_KEYWORD ),
   ENTRY( "\\", TKF_NONE ),
   ENTRY( "reopen", TKF_KEYWORD ),
   ENTRY( "let", TKF_KEYWORD ),
};
#undef ENTRY

const struct token_info* p_get_token_info( enum tk tk ) {
   STATIC_ASSERT( TK_TOTAL == 149 );
   return &g_table[ tk ];
}

const struct token_info* p_find_keyword( const char* text ) {
   for ( int i = 0; i < ARRAY_SIZE( g_table ); ++i ) {
      if ( g_table[ i ].flags & TKF_KEYWORD &&
         strcmp( g_table[ i ].shared_text, text ) == 0 ) {
         return &g_table[ i ];
      }
   }
   return NULL;
}

const char* p_get_token_name( enum tk tk ) {
   static const struct { enum tk tk; const char* name; } names[] = {
      { TK_BRACKET_L, "`[`" },
      { TK_BRACKET_R, "`]`" },
      { TK_PAREN_L, "`(`" },
      { TK_PAREN_R, "`)`" },
      { TK_BRACE_L, "`{`" },
      { TK_BRACE_R, "`}`" },
      { TK_DOT, "`.`" },
      { TK_INC, "`++`" },
      { TK_DEC, "`--`" },
      { TK_COMMA, "`,`" },
      { TK_COLON, "`:`" },
      { TK_SEMICOLON, "`;`" },
      { TK_ASSIGN, "`=`" },
      { TK_ASSIGN_ADD, "`+=`" },
      { TK_ASSIGN_SUB, "`-=`" },
      { TK_ASSIGN_MUL, "`*=`" },
      { TK_ASSIGN_DIV, "`/=`" },
      { TK_ASSIGN_MOD, "`%=`" },
      { TK_ASSIGN_SHIFT_L, "`<<=`" },
      { TK_ASSIGN_SHIFT_R, "`>>=`" },
      { TK_ASSIGN_BIT_AND, "`&=`" },
      { TK_ASSIGN_BIT_XOR, "`^=`" },
      { TK_ASSIGN_BIT_OR, "`|=`" },
      { TK_EQ, "`==`" },
      { TK_NEQ, "`!=`" },
      { TK_LOG_NOT, "`!`" },
      { TK_LOG_AND, "`&&`" },
      { TK_LOG_OR, "`||`" },
      { TK_BIT_AND, "`&`" },
      { TK_BIT_OR, "`|`" },
      { TK_BIT_XOR, "`^`" },
      { TK_BIT_NOT, "`~`" },
      { TK_LT, "`<`" },
      { TK_LTE, "`<=`" },
      { TK_GT, "`>`" },
      { TK_GTE, "`>=`" },
      { TK_PLUS, "`+`" },
      { TK_MINUS, "`-`" },
      { TK_SLASH, "`/`" },
      { TK_STAR, "`*`" },
      { TK_MOD, "`%`" },
      { TK_SHIFT_L, "`<<`" },
      { TK_SHIFT_R, "`>>`" },
      { TK_HASH, "`#`" },
      { TK_BREAK, "`break`" },
      { TK_CASE, "`case`" },
      { TK_CONST, "`const`" },
      { TK_CONTINUE, "`continue`" },
      { TK_DEFAULT, "`default`" },
      { TK_DO, "`do`" },
      { TK_ELSE, "`else`" },
      { TK_ENUM, "`enum`" },
      { TK_FOR, "`for`" },
      { TK_IF, "`if`" },
      { TK_INT, "`int`" },
      { TK_RETURN, "`return`" },
      { TK_STATIC, "`static`" },
      { TK_STR, "`str`" },
      { TK_STRUCT, "`struct`" },
      { TK_SWITCH, "`switch`" },
      { TK_VOID, "`void`" },
      { TK_WHILE, "`while`" },
      { TK_BOOL, "`bool`" },
      { TK_PALTRANS, "`createtranslation`" },
      { TK_GLOBAL, "`global`" },
      { TK_SCRIPT, "`script`" },
      { TK_UNTIL, "`until`" },
      { TK_WORLD, "`world`" },
      { TK_OPEN, "`open`" },
      { TK_RESPAWN, "`respawn`" },
      { TK_DEATH, "`death`" },
      { TK_ENTER, "`enter`" },
      { TK_PICKUP, "`pickup`" },
      { TK_BLUE_RETURN, "`bluereturn`" },
      { TK_RED_RETURN, "`redreturn`" },
      { TK_WHITE_RETURN, "`whitereturn`" },
      { TK_LIGHTNING, "`lightning`" },
      { TK_DISCONNECT, "`disconnect`" },
      { TK_UNLOADING, "`unloading`" },
      { TK_CLIENTSIDE, "`clientside`" },
      { TK_NET, "`net`" },
      { TK_RESTART, "`restart`" },
      { TK_SUSPEND, "`suspend`" },
      { TK_TERMINATE, "`terminate`" },
      { TK_FUNCTION, "`function`" },
      { TK_IMPORT, "`import`" },
      { TK_GOTO, "`goto`" },
      { TK_TRUE, "`true`" },
      { TK_FALSE, "`false`" },
      { TK_IMPORT, "`import`" },
      { TK_EVENT, "`event`" },
      { TK_LIT_OCTAL, "octal number" },
      { TK_LIT_DECIMAL, "decimal number" },
      { TK_LIT_HEX, "hexadecimal number" },
      { TK_LIT_BINARY, "binary number" },
      { TK_LIT_FIXED, "fixed-point number" },
      { TK_NL, "end-of-line" },
      { TK_END, "end-of-input" },
      { TK_LIB, "start-of-library" },
      { TK_LIB_END, "end-of-library" },
      { TK_QUESTION_MARK, "`?`" },
      { TK_ELLIPSIS, "`...`" },
      { TK_HORZSPACE, "horizontal space" },
      { TK_HASHHASH, "`##`" },
      { TK_STRCPY, "`strcpy`" },
      { TK_RAW, "`raw`" },
      { TK_FIXED, "`fixed`" },
      { TK_ASSERT, "`assert`" },
      { TK_AUTO, "`auto`" },
      { TK_TYPEDEF, "`typedef`" },
      { TK_FOREACH, "`foreach`" },
      { TK_PRIVATE, "`private`" },
      { TK_MEMCPY, "`memcpy`" },
      { TK_MSGBUILD, "`msgbuild`" },
      { TK_NULL, "`null`" },
      { TK_SPECIAL, "`special`" },
      { TK_NAMESPACE, "`namespace`" },
      { TK_UPMOST, "`upmost`" },
      { TK_USING, "`using`" },
      { TK_INCLUDE, "`include`" },
      { TK_DEFINE, "`define`" },
      { TK_LIBDEFINE, "`libdefine`" },
      { TK_PRINT, "`print`" },
      { TK_PRINTBOLD, "`printbold`" },
      { TK_WADAUTHOR, "`wadauthor`" },
      { TK_NOWADAUTHOR, "`nowadauthor`" },
      { TK_NOCOMPACT, "`nocompact`" },
      { TK_LIBRARY, "`library`" },
      { TK_ENCRYPTSTRINGS, "`encryptstrings`" },
      { TK_REGION, "`region`" },
      { TK_ENDREGION, "`endregion`" },
      { TK_LOG, "`log`" },
      { TK_HUDMESSAGE, "`hudmessage`" },
      { TK_HUDMESSAGEBOLD, "`hudmessagebold`" },
      { TK_STRPARAM, "`strparam`" },
      { TK_EXTERN, "`extern`" },
      { TK_ACSEXECUTEWAIT, "`acs_executewait`" },
      { TK_ACSNAMEDEXECUTEWAIT, "`acs_namedexecutewait`" },
      { TK_LIT_RADIX, "radix number" },
      { TK_KILL, "`kill`" },
      { TK_BACKSLASH, "`\\`" },
      { TK_REOPEN, "`reopen`" },
      { TK_LET, "`let`" } };
   STATIC_ASSERT( TK_TOTAL == 149 );
   switch ( tk ) {
   case TK_LIT_STRING:
      return "string literal";
   case TK_LIT_CHAR:
      return "character literal";
   case TK_ID:
      return "identifier";
   case TK_TYPENAME:
      return "type name (identifier that ends with \"_T\")";
   default:
      for ( size_t i = 0; i < ARRAY_SIZE( names ); ++i ) {
         if ( names[ i ].tk == tk ) {
            return names[ i ].name;
         }
      }
      return "";
   }
}